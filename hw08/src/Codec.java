 /*  Name: Allison Chen
  *  PennKey: allchen
  *  Recitation: 209
  *
  *  A class that will encode and decode
  */

public class Codec {

   /*
    * Description: takes in a character and converts it
    *              to a binary representation of its ASCII value.
    *              it will return an int[] where each element is
    *              a single bit (i.e. 1 or 0) in the ASCII encoding
    *              of the character ch using 7 bits.
    * Input:       character to be converted
    * Output:      int array representing the ASCII
    *              encoding of the character
    */
    private static int[] charToIntArray(char ch) {
        int intRep = (int) ch; 
        int [] temp = new int [7];
        int i = 0;

        while (intRep > 0) {
            temp [i] = intRep % 2;
            intRep /= 2;
            i++;
        }

        int [] binary = new int [7];
        int j = 0;

        for (int k = 6; k >= 0; k--) {
            binary [j] = temp [k];
            j++;
        }

        return binary; 
    }

   /*
    * Description: takes in an int[] of length 7 where
    *              each element is a single bit (i.e. 1 or 0)
    *              in the ASCII encoding of a character ch
    *              and outputs the character that is encoded.
    * Input:       int array representing the bitSring
    * Output:      the character that is encoded
    */
    private static char intArrayToChar(int[] bitString) {
        int num = 0;
        int pow = 0;

        for (int i = bitString.length - 1; i >= 0; i--) {
            num += bitString[i] * Math.pow(2, pow);
            pow++; 
        }
        char letter = (char) num;
        return letter;
    }

   /*
    * Description: takes in a String and will return an int[]
    *              where each element is a single bit
    *              in the ASCII encoding of the String.
    *              each character in str will encode into 7 bits,
    *              so the output array should be 7 times larger
    *              than the length of the String.
    * Input:       the String to be encoded
    * Output:      the int array encoding of the String
    */
    public static int[] encode(String str) {
        if (str == null) {
            return null;
        }

        int [] bit = new int [7 * str.length()];
        for (int i = 0; i < str.length(); i++) {
            if ((int) str.charAt(i) > 127) {
                throw new RuntimeException("ERROR: character in String" + 
                                           "has an invalid unicode value");
            } else bit = charToIntArray(str.charAt(i));
        }
        return bit;
    }

   /*
    * Description: accepts an array of ints representing
    *              a message in ASCII and will return
    *              the decoded String. 
    *              an error will be thrown if:
    *                  the length of the bits array is not a multiple of 7
    *                  if the bits array contains any values other than 0 and 1
    * Input:       the array of bits representing the message in ASCII
    * Output:      the decoded String
    */
    public static String decode(int[] bits) {
        if (bits == null) {
            return null;
        }

        if (bits.length % 7 != 0) {
            throw new RuntimeException("ERROR: bit size is not a multiple of 7");
        }

        String decoded = "";
        int[] temp = new int [7];
        for (int i = 0; i < bits.length; i += 7) {
            if (bits[i] != 0 && bits [i] != 1) {
                throw new RuntimeException("ERROR: contains values" + 
                                           "other than 0 and 1");
            }
            for (int j = 0; j < temp.length; j++) {
                temp [j] = bits [i + j];
            }
            decoded += intArrayToChar(temp);
        }
        return decoded;
    }

   /*
    * Description: encrypts by xor-ing message with a sequence
    *              of pseudo-random bits generated by the LFSR.
    *              if the message is null nothing will happen
    *
    *              an error will be thrown if:
    *                  seed is null
    *                  tapPosiion is impossible
    *                  seed contains any characters other than '0' and '1'
    *                  message length is not a multiple of 7
    *                  any entry in the message array contains
    *                  a value other than 0 or 1
    *                  
    * Input:       message is the message in binary to encrypt
    *              seed and tapPosition are the parameters
    *              for the LFSR to be used when encrypting
    * Output:      n/a
    */
    public static void encrypt(int[] message, String seed, int tapPosition) {
        if (seed == null) {
            throw new RuntimeException("ERROR: seed is null");
        }

        if (tapPosition < 0) {
            throw new RuntimeException("ERROR: tap position is impossible");
        }

        for (int i = 0; i < seed.length(); i++) {
            if (seed.charAt(i) != '0' && seed.charAt(i) != '1') {
                throw new RuntimeException("ERROR: seed contains" +
                                           "characters other than 0 and 1");
            }
        }

        if (message.length % 7 != 0) {
            throw new RuntimeException("ERROR: message length" +
                                       "is not a multiple of 7");
        }

        for (int j = 0; j < message.length; j++) {
            if (message[j] != 0 && message[j] != 1) {
                throw new RuntimeException("ERROR: message contains" + 
                                           "value other than 0 or 1");
            }
        }

        LFSR encrypt = new LFSR(seed, tapPosition);
        for (int i = 0; i < message.length; i++) {
            message [i] = message [i] ^ encrypt.nextBit();
        }
    }

   /*
    * Description: decrypts a given cipher given the seed and
    *              and tapPosition to be used
    * Input:       int array representing the cipher to decrypt
    *              seed and tapPosition
    * Output:      n/a
    */
    public static void decrypt(int[] cipher, String seed, int tapPosition) {
        //because xor is symmetric (opposite)
        encrypt(cipher, seed, tapPosition);
    }

    public static void main(String[] args) {

    }
}